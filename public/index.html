<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Availability Calendar</title>
    
    <!-- Telegram WebApp SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Alpine.js -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    
    <!-- Shoelace -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.1/cdn/themes/light.css" />
    <script type="module" src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.1/cdn/shoelace-autoloader.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--sl-color-neutral-50);
            padding: 1rem;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
        }
        
        .header {
            margin-bottom: 1rem;
        }
        
        .calendar-container {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .tabs-container {
            margin-bottom: 1rem;
        }
        
        .tabs {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding-bottom: 0.5rem;
        }
        
        .tab {
            padding: 0.75rem 1rem;
            background: var(--sl-color-neutral-100);
            border: 1px solid var(--sl-color-neutral-300);
            border-radius: var(--sl-border-radius-medium);
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
            font-size: 0.875rem;
            width: 100%;
            text-align: center;
        }
        
        .tab:hover {
            background: var(--sl-color-neutral-200);
        }
        
        .tab.active {
            background: var(--sl-color-primary-500);
            color: white;
            border-color: var(--sl-color-primary-600);
        }
        
        .calendar-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 2px;
            width: 100%;
        }
        
        
        .grid-header {
            background: var(--sl-color-neutral-100);
            padding: 0.75rem;
            text-align: center;
            font-weight: 600;
            font-size: 1rem;
            position: sticky;
            left: 0;
            z-index: 2;
        }
        
        .date-header {
            background: var(--sl-color-primary-50);
            padding: 0.5rem;
            text-align: center;
            font-weight: 600;
            font-size: 0.875rem;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        
        .hour-row-wrapper {
            display: contents;
        }
        
        .hour-label {
            padding: 0.75rem 0.5rem;
            text-align: center;
            font-size: 1rem;
            font-weight: 600;
            position: sticky;
            left: 0;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 48px;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        
        .hour-label.green {
            background: var(--sl-color-success-500);
        }
        
        .hour-label.yellow {
            background: #fbbf24;
        }
        
        .hour-label.red {
            background: var(--sl-color-danger-500);
        }
        
        .status-buttons {
            display: flex;
            gap: 4px;
            padding: 4px;
            background: var(--sl-color-neutral-100);
            border-radius: 4px;
            align-items: center;
            min-height: 48px;
        }
        
        .status-button {
            flex: 1;
            min-width: 40px;
            min-height: 40px;
            height: 40px;
            border: 1px solid var(--sl-color-neutral-300);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 5;
            -webkit-tap-highlight-color: transparent;
        }
        
        .status-button:hover {
            transform: scale(1.1);
            z-index: 10;
        }
        
        .status-button.green {
            background: var(--sl-color-success-500);
        }
        
        .status-button.yellow {
            background: #fbbf24;
        }
        
        .status-button.red {
            background: var(--sl-color-danger-500);
        }
        
        .status-button.active {
            border-width: 2px;
            border-color: var(--sl-color-neutral-900);
            box-shadow: 0 0 0 2px var(--sl-color-primary-200);
        }
        
        
        .loading {
            text-align: center;
            padding: 2rem;
        }
        
        .error {
            color: var(--sl-color-danger-600);
            padding: 1rem;
            background: var(--sl-color-danger-50);
            border-radius: var(--sl-border-radius-medium);
            margin-bottom: 1rem;
        }
        
        .user-list {
            margin-bottom: 1rem;
            padding: 1rem;
            background: white;
            border-radius: var(--sl-border-radius-medium);
        }
        
        .user-item {
            display: inline-block;
            margin-right: 1rem;
            margin-bottom: 0.5rem;
        }
        
        .color-legend {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid var(--sl-color-neutral-300);
        }
        
        .view-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .view-tab {
            flex: 1;
            padding: 0.75rem 1rem;
            background: var(--sl-color-neutral-100);
            border: 1px solid var(--sl-color-neutral-300);
            border-radius: var(--sl-border-radius-medium);
            cursor: pointer;
            text-align: center;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .view-tab:hover {
            background: var(--sl-color-neutral-200);
        }
        
        .view-tab.active {
            background: var(--sl-color-primary-500);
            color: white;
            border-color: var(--sl-color-primary-600);
        }
        
        .overview-container {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .overview-table {
            display: grid;
            grid-template-columns: 120px repeat(24, 1fr);
            gap: 2px;
            width: 100%;
        }
        
        .overview-header-row {
            display: contents;
        }
        
        .overview-user-header,
        .overview-hour-header {
            background: var(--sl-color-primary-50);
            padding: 0.75rem 0.5rem;
            text-align: center;
            font-weight: 600;
            font-size: 0.875rem;
            position: sticky;
            top: 0;
            z-index: 2;
        }
        
        .overview-user-header {
            left: 0;
            z-index: 3;
        }
        
        .overview-user-row {
            display: contents;
        }
        
        .overview-user-name {
            background: var(--sl-color-neutral-100);
            padding: 0.75rem 0.5rem;
            font-weight: 500;
            font-size: 0.875rem;
            position: sticky;
            left: 0;
            z-index: 1;
            border-right: 1px solid var(--sl-color-neutral-300);
        }
        
        .overview-cell {
            min-height: 40px;
            border: 1px solid var(--sl-color-neutral-200);
            transition: all 0.2s;
        }
        
        .overview-cell.green {
            background: var(--sl-color-success-500);
        }
        
        .overview-cell.yellow {
            background: #fbbf24;
        }
        
        .overview-cell.red {
            background: var(--sl-color-danger-500);
        }
    </style>
</head>
<body>
    <div x-data="availabilityApp()" x-init="init()" class="container">
        <div class="header">
            <h1>Availability Calendar</h1>
            <p x-text="dateRangeText"></p>
        </div>
        
        <div x-show="error" class="error" x-text="error"></div>
        
        <div class="color-legend">
            <div class="legend-item">
                <div class="legend-color" style="background: var(--sl-color-success-500);"></div>
                <span>Available</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #fbbf24;"></div>
                <span>Maybe</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: var(--sl-color-danger-500);"></div>
                <span>Unavailable</span>
            </div>
        </div>
        
        <div x-show="loading" class="loading">
            <sl-spinner></sl-spinner>
            <p>Loading availability...</p>
        </div>
        
        <div x-show="!loading && !error">
            <!-- View toggle -->
            <div class="view-toggle">
                <div 
                    class="view-tab"
                    :class="{ active: viewMode === 'individual' }"
                    @click="viewMode = 'individual'"
                >
                    My Availability
                </div>
                <div 
                    class="view-tab"
                    :class="{ active: viewMode === 'overview' }"
                    @click="viewMode = 'overview'"
                >
                    Team Overview
                </div>
            </div>
            
            <!-- Day tabs -->
            <div class="tabs-container">
                <div class="tabs">
                    <template x-for="(date, index) in dates" :key="date">
                        <div 
                            class="tab"
                            :class="{ active: selectedDateIndex === index }"
                            @click="selectedDateIndex = index"
                            x-text="formatDate(date)"
                        ></div>
                    </template>
                </div>
            </div>
            
            <!-- Individual view: Calendar grid for selected day -->
            <div x-show="viewMode === 'individual'" class="calendar-container">
                <div class="calendar-grid">
                    <!-- Header row -->
                    <div class="grid-header">
                        <span style="font-weight: 600; font-size: 1rem;">Hour</span>
                    </div>
                    <div class="status-buttons" style="background: var(--sl-color-primary-50); padding: 0.75rem; justify-content: center;">
                        <span style="font-weight: 600; font-size: 1rem;">Status</span>
                    </div>
                    
                    <!-- Rows for each hour -->
                    <template x-for="hour in hours" :key="hour">
                        <div style="display: contents;">
                            <div 
                                class="hour-label"
                                :class="getSlotClass(dates[selectedDateIndex], hour)"
                                x-text="String(hour).padStart(2, '0')"
                                :title="getSlotTitle(dates[selectedDateIndex], hour)"
                            ></div>
                            <div class="status-buttons">
                                <template x-for="status in statuses" :key="status">
                                    <div 
                                        class="status-button"
                                        :class="[status, { active: getSlotStatus(dates[selectedDateIndex], hour) === status }]"
                                        @click.stop="setSlotStatus(dates[selectedDateIndex], hour, status)"
                                        @touchstart.stop="setSlotStatus(dates[selectedDateIndex], hour, status)"
                                        :title="status.charAt(0).toUpperCase() + status.slice(1)"
                                    ></div>
                                </template>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
            
            <!-- Overview view: Table showing all users -->
            <div x-show="viewMode === 'overview'" class="overview-container">
                <div class="overview-table">
                    <!-- Header row with hours -->
                    <div class="overview-header-row">
                        <div class="overview-user-header">User</div>
                        <template x-for="hour in hours" :key="hour">
                            <div class="overview-hour-header" x-text="String(hour).padStart(2, '0')"></div>
                        </template>
                    </div>
                    
                    <!-- Rows for each user -->
                    <template x-for="user in getAllUsers()" :key="user.user_id">
                        <div class="overview-user-row">
                            <div class="overview-user-name" x-text="user.display_name || 'User'"></div>
                            <template x-for="hour in hours" :key="hour">
                                <div 
                                    class="overview-cell"
                                    :class="getUserStatusClass(user.user_id, dates[selectedDateIndex], hour)"
                                    :title="getUserStatusTitle(user.user_id, dates[selectedDateIndex], hour)"
                                ></div>
                            </template>
                        </div>
                    </template>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        function availabilityApp() {
            return {
                loading: true,
                error: null,
                currentUser: null,
                availability: [],
                dates: [],
                selectedDateIndex: 0,
                viewMode: 'individual', // 'individual' or 'overview'
                hours: Array.from({ length: 24 }, (_, i) => i),
                statuses: ['green', 'yellow', 'red'],
                
                init() {
                    // Initialize Telegram WebApp (if available)
                    if (window.Telegram?.WebApp) {
                        window.Telegram.WebApp.ready();
                        window.Telegram.WebApp.expand();
                    } else {
                        console.log('Running in development mode (no Telegram WebApp)');
                    }
                    
                    // Calculate date range (today through 7 days later)
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    this.dates = [];
                    for (let i = 0; i < 8; i++) {
                        const date = new Date(today);
                        date.setDate(today.getDate() + i);
                        this.dates.push(date.toISOString().split('T')[0]);
                    }
                    
                    this.loadUser();
                    this.loadAvailability();
                },
                
                async loadUser() {
                    try {
                        // Get init data if available (Telegram WebApp), otherwise empty (dev mode)
                        const initData = window.Telegram?.WebApp?.initData || '';
                        const headers = {};
                        if (initData) {
                            headers['x-telegram-init-data'] = initData;
                        }
                        
                        const response = await fetch('/api/user', {
                            headers: headers
                        });
                        
                        if (!response.ok) {
                            throw new Error('Failed to load user');
                        }
                        
                        this.currentUser = await response.json();
                    } catch (error) {
                        console.error('Error loading user:', error);
                        this.error = 'Failed to load user data';
                    }
                },
                
                async loadAvailability() {
                    try {
                        const startDate = this.dates[0];
                        const endDate = this.dates[this.dates.length - 1];
                        
                        const response = await fetch(`/api/availability?startDate=${startDate}&endDate=${endDate}`);
                        
                        if (!response.ok) {
                            throw new Error('Failed to load availability');
                        }
                        
                        const newAvailability = await response.json();
                        console.log('[Frontend] loadAvailability - loaded', newAvailability.length, 'items');
                        // Replace the entire array to trigger Alpine.js reactivity
                        this.availability = newAvailability;
                        this.loading = false;
                    } catch (error) {
                        console.error('Error loading availability:', error);
                        this.error = 'Failed to load availability data';
                        this.loading = false;
                    }
                },
                
                getSlotClass(date, hour) {
                    const status = this.getSlotStatus(date, hour);
                    return status || 'red'; // Default to red (unavailable)
                },
                
                getSlotStatus(date, hour) {
                    const slot = this.getUserSlot(date, hour);
                    return slot ? slot.status : 'red'; // Default to red
                },
                
                getUserSlot(date, hour) {
                    if (!this.currentUser) return null;
                    
                    // Normalize date - handle both date strings and timestamps
                    const normalizeDate = (d) => {
                        if (!d) return '';
                        // If it's already a date string (YYYY-MM-DD), return it
                        if (typeof d === 'string' && d.match(/^\d{4}-\d{2}-\d{2}$/)) {
                            return d;
                        }
                        // If it's a timestamp, extract the date part
                        try {
                            const dateObj = new Date(d);
                            return dateObj.toISOString().split('T')[0];
                        } catch (e) {
                            console.error('[Frontend] Error normalizing date:', d, e);
                            return String(d).split('T')[0]; // Fallback: just take the date part
                        }
                    };
                    
                    const normalizedDate = normalizeDate(date);
                    console.log('[Frontend] getUserSlot:', { 
                        date, 
                        normalizedDate,
                        hour, 
                        currentUserId: this.currentUser.user_id,
                        availabilityCount: this.availability.length
                    });
                    
                    const slot = this.availability.find(
                        a => {
                            const userMatch = String(a.user_id) === String(this.currentUser.user_id);
                            const aDateNormalized = normalizeDate(a.date);
                            const dateMatch = aDateNormalized === normalizedDate;
                            const hourMatch = Number(a.hour) === Number(hour);
                            
                            if (userMatch && dateMatch) {
                                console.log('[Frontend] Found matching user/date:', { 
                                    a_user_id: a.user_id, 
                                    a_date: a.date,
                                    a_date_normalized: aDateNormalized,
                                    target_date: normalizedDate,
                                    a_hour: a.hour, 
                                    target_hour: hour, 
                                    hourMatch,
                                    status: a.status
                                });
                            }
                            
                            return userMatch && dateMatch && hourMatch;
                        }
                    );
                    
                    console.log('[Frontend] getUserSlot result:', slot);
                    return slot;
                },
                
                getAllUsersForSlot(date, hour) {
                    return this.availability.filter(
                        a => a.date === date && a.hour === hour
                    );
                },
                
                getAllUsers() {
                    // Get unique users from availability data
                    const userMap = new Map();
                    this.availability.forEach(a => {
                        if (!userMap.has(a.user_id)) {
                            userMap.set(a.user_id, {
                                user_id: a.user_id,
                                display_name: a.display_name || 'User'
                            });
                        }
                    });
                    // Always include current user
                    if (this.currentUser && !userMap.has(this.currentUser.user_id)) {
                        userMap.set(this.currentUser.user_id, {
                            user_id: this.currentUser.user_id,
                            display_name: this.currentUser.display_name || 'User'
                        });
                    }
                    return Array.from(userMap.values()).sort((a, b) => 
                        (a.display_name || '').localeCompare(b.display_name || '')
                    );
                },
                
                getUserStatus(userId, date, hour) {
                    // Normalize date for comparison
                    const normalizeDate = (d) => {
                        if (!d) return '';
                        if (typeof d === 'string' && d.match(/^\d{4}-\d{2}-\d{2}$/)) {
                            return d;
                        }
                        try {
                            const dateObj = new Date(d);
                            return dateObj.toISOString().split('T')[0];
                        } catch (e) {
                            return String(d).split('T')[0];
                        }
                    };
                    
                    const normalizedDate = normalizeDate(date);
                    const slot = this.availability.find(
                        a => {
                            const userMatch = String(a.user_id) === String(userId);
                            const aDateNormalized = normalizeDate(a.date);
                            const dateMatch = aDateNormalized === normalizedDate;
                            const hourMatch = Number(a.hour) === Number(hour);
                            return userMatch && dateMatch && hourMatch;
                        }
                    );
                    return slot ? slot.status : 'red'; // Default to red
                },
                
                getUserStatusClass(userId, date, hour) {
                    const status = this.getUserStatus(userId, date, hour);
                    return status || 'red';
                },
                
                getUserStatusTitle(userId, date, hour) {
                    const user = this.getAllUsers().find(u => String(u.user_id) === String(userId));
                    const userName = user ? user.display_name : 'User';
                    const hourStr = String(hour).padStart(2, '0');
                    const status = this.getUserStatus(userId, date, hour);
                    return `${userName} - ${this.formatDate(date)} ${hourStr}:00 - ${status.charAt(0).toUpperCase() + status.slice(1)}`;
                },
                
                getSlotContent(date, hour) {
                    const allUsers = this.getAllUsersForSlot(date, hour);
                    if (allUsers.length === 0) return '';
                    
                    // Show user names for this slot
                    return allUsers.map(u => u.display_name || 'User').join(', ');
                },
                
                getSlotTitle(date, hour) {
                    const allUsers = this.getAllUsersForSlot(date, hour);
                    const hourStr = String(hour).padStart(2, '0');
                    const currentStatus = this.getSlotStatus(date, hour);
                    if (allUsers.length === 0) {
                        return `${this.formatDate(date)} ${hourStr}:00 - ${currentStatus.charAt(0).toUpperCase() + currentStatus.slice(1)} (default)`;
                    }
                    return `${this.formatDate(date)} ${hourStr}:00 - ${allUsers.map(u => `${u.display_name}: ${u.status}`).join(', ')}`;
                },
                
                async setSlotStatus(date, hour, status) {
                    console.log('[Frontend] setSlotStatus called:', { date, hour, status, currentUser: this.currentUser });
                    
                    if (!this.currentUser) {
                        console.error('[Frontend] No current user');
                        this.error = 'User not loaded';
                        return;
                    }
                    
                    try {
                        // Get init data if available (Telegram WebApp), otherwise empty (dev mode)
                        const initData = window.Telegram?.WebApp?.initData || '';
                        const headers = {
                            'Content-Type': 'application/json'
                        };
                        if (initData) {
                            headers['x-telegram-init-data'] = initData;
                        }
                        
                        const requestBody = {
                            date,
                            hour,
                            status: status
                        };
                        console.log('[Frontend] Sending request:', requestBody);
                        
                        const response = await fetch('/api/availability', {
                            method: 'POST',
                            headers: headers,
                            body: JSON.stringify(requestBody)
                        });
                        
                        console.log('[Frontend] Response status:', response.status, response.statusText);
                        
                        if (!response.ok) {
                            const errorText = await response.text();
                            console.error('[Frontend] Response error:', errorText);
                            throw new Error('Failed to save availability');
                        }
                        
                        const saved = await response.json();
                        console.log('[Frontend] Response data:', saved);
                        console.log('[Frontend] Current availability before update:', this.availability.length, 'items');
                        
                        // If status is 'red', remove the record from local state (it was deleted)
                        if (status === 'red' || saved.deleted) {
                            console.log('[Frontend] Deleting record from local state');
                            const index = this.availability.findIndex(
                                a => String(a.user_id) === String(saved.user_id) && 
                                     a.date === saved.date && 
                                     a.hour === saved.hour
                            );
                            console.log('[Frontend] Found index to delete:', index);
                            if (index >= 0) {
                                this.availability.splice(index, 1);
                                console.log('[Frontend] Record deleted, new availability count:', this.availability.length);
                            } else {
                                console.log('[Frontend] No record found to delete');
                            }
                        } else {
                            console.log('[Frontend] Upserting record');
                            // Update or add the record for green/yellow
                            const index = this.availability.findIndex(
                                a => String(a.user_id) === String(saved.user_id) && 
                                     a.date === saved.date && 
                                     a.hour === saved.hour
                            );
                            
                            console.log('[Frontend] Found index to update:', index);
                            if (index >= 0) {
                                // Use Object.assign to ensure Alpine.js detects the change
                                Object.assign(this.availability[index], saved);
                                console.log('[Frontend] Record updated:', this.availability[index]);
                            } else {
                                // Add user info if missing
                                saved.display_name = this.currentUser.display_name;
                                this.availability.push(saved);
                                console.log('[Frontend] Record added, new availability count:', this.availability.length);
                            }
                        }
                        
                        // Force Alpine.js to react to the change
                        this.$nextTick(() => {
                            console.log('[Frontend] Next tick - availability updated');
                        });
                        
                        // Reload to get all users (but keep our local changes)
                        console.log('[Frontend] Reloading availability...');
                        await this.loadAvailability();
                        console.log('[Frontend] Availability reloaded, new count:', this.availability.length);
                    } catch (error) {
                        console.error('Error saving availability:', error);
                        this.error = 'Failed to save availability';
                    }
                },
                
                formatDate(dateStr) {
                    const date = new Date(dateStr);
                    const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    return `${days[date.getDay()]} ${months[date.getMonth()]} ${date.getDate()}`;
                },
                
                get dateRangeText() {
                    if (this.dates.length === 0) return '';
                    const start = this.formatDate(this.dates[0]);
                    const end = this.formatDate(this.dates[this.dates.length - 1]);
                    return `${start} - ${end}`;
                }
            };
        }
    </script>
</body>
</html>
